import 'dart:async';

import 'package:dominoes_tracker/features/sessions/domain/usecases/get_total_sessions.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/enums/usecase_status.dart';
import '../../../../core/usecases/usecase.dart';
import '../../../players/domain/entities/player.dart';
import '../../../players/domain/usecases/add_player.dart';
import '../../../players/domain/usecases/get_players.dart';
import '../../domain/entities/session.dart';
import '../../domain/usecases/add_round.dart';
import '../../domain/usecases/complete_session.dart';
import '../../domain/usecases/start_session.dart';
import '../../domain/usecases/watch_session.dart';

part 'session_state.dart';

class SessionCubit extends Cubit<SessionState> {
  final StartSession startSessionUseCase;
  final GetTotalSessions getTotalSessionsUseCase;
  final AddRound addRoundUseCase;
  final WatchSession watchSessionUseCase;
  final CompleteSession completeSessionUseCase;
  final GetPlayers getPlayersUseCase;
  final AddPlayer addPlayerUseCase;

  StreamSubscription? _sessionSubscription;

  SessionCubit({
    required this.getTotalSessionsUseCase,
    required this.startSessionUseCase,
    required this.addRoundUseCase,
    required this.watchSessionUseCase,
    required this.completeSessionUseCase,
    required this.getPlayersUseCase,
    required this.addPlayerUseCase,
  }) : super(SessionState());

  Future<void> loadSessionsCount() async {
    emit(state.copyWith(countStatus: UseCaseStatus.loading));
    try {
      final totalSessions = await getTotalSessionsUseCase(NoParams());
      await seedInitialPlayers();
      emit(state.copyWith(countStatus: UseCaseStatus.success, count: totalSessions));
    } catch (e) {
      emit(state.copyWith(countStatus: UseCaseStatus.failure, countError: e.toString()));
    }
  }

  Future<void> seedInitialPlayers() async {
    try {
      final players = await getPlayersUseCase(NoParams());
      if (players.isEmpty) {
        final initialPlayers = [
          const Player(id: '0', name: 'Uncle Tony', avatarUrl: 'https://api.dicebear.com/7.x/avataaars/svg?seed=Tony'),
          const Player(id: '1', name: 'Sarah Miller', avatarUrl: 'https://api.dicebear.com/7.x/avataaars/svg?seed=Sarah'),
          const Player(id: '2', name: 'Mike Ross', avatarUrl: 'https://api.dicebear.com/7.x/avataaars/svg?seed=Mike'),
          const Player(id: '3', name: 'Jessica Pearson', avatarUrl: 'https://api.dicebear.com/7.x/avataaars/svg?seed=Jessica'),
        ];

        for (final player in initialPlayers) {
          await addPlayerUseCase(player);
        }
      }
    } catch (e) {
      print('Error seeding players: $e');
    }
  }

  Future<void> createSession({required String team1Name, required String team2Name, required int limit}) async {
    emit(state.copyWith(sessionStatus: UseCaseStatus.loading));
    try {
      final session = Session(
        id: '', // Will be generated by Firestore
        date: DateTime.now(),
        team1Score: 0,
        team2Score: 0,
        team1Name: team1Name,
        team2Name: team2Name,
      );
      final sessionId = await startSessionUseCase(session);
      watchSession(sessionId);
    } catch (e) {
      emit(state.copyWith(sessionStatus: UseCaseStatus.failure, sessionError: e.toString()));
    }
  }

  void watchSession(String sessionId) {
    _sessionSubscription?.cancel();
    _sessionSubscription = watchSessionUseCase(sessionId).listen(
      (session) {
        emit(state.copyWith(sessionStatus: UseCaseStatus.success, session: session));
      },
      onError: (e) {
        emit(state.copyWith(sessionStatus: UseCaseStatus.failure, sessionError: e.toString()));
      },
    );
  }

  Future<void> recordRound(String winningTeam, int points) async {
    final state = this.state;
    if (state.sessionStatus == UseCaseStatus.success && state.session != null) {
      try {
        await addRoundUseCase(state.session!.id, winningTeam, points);
        // Note: Score updates in Firestore are usually handled by a cloud function
        // or client-side calculation. For now, we'll assume the client updates the total score
        // to keep it simple, or Firestore triggers might do it.
        // Actually, let's keep it simple and just add the round.
      } catch (e) {
        emit(state.copyWith(sessionStatus: UseCaseStatus.failure, sessionError: e.toString()));
      }
    }
  }

  Future<void> finishSession() async {
    final state = this.state;
    if (state.sessionStatus == UseCaseStatus.success && state.session != null) {
      try {
        await completeSessionUseCase(state.session!.id);
        emit(state.copyWith(sessionStatus: UseCaseStatus.success, session: state.session));
      } catch (e) {
        emit(state.copyWith(sessionStatus: UseCaseStatus.failure, sessionError: e.toString()));
      }
    }
  }

  @override
  Future<void> close() {
    _sessionSubscription?.cancel();
    return super.close();
  }
}
