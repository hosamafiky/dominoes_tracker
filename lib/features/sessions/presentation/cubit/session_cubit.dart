import 'dart:async';

import 'package:dominoes_tracker/features/sessions/domain/usecases/get_total_sessions.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../../core/enums/usecase_status.dart';
import '../../../players/domain/usecases/add_player.dart';
import '../../../players/domain/usecases/get_players.dart';
import '../../domain/entities/session.dart';
import '../../domain/usecases/add_round.dart';
import '../../domain/usecases/complete_session.dart';
import '../../domain/usecases/start_session.dart';
import '../../domain/usecases/watch_session.dart';

part 'session_state.dart';

class SessionCubit extends Cubit<SessionState> {
  final StartSession startSessionUseCase;
  final GetTotalSessions getTotalSessionsUseCase;
  final AddRound addRoundUseCase;
  final WatchSession watchSessionUseCase;
  final CompleteSession completeSessionUseCase;
  final GetPlayers getPlayersUseCase;
  final AddPlayer addPlayerUseCase;

  StreamSubscription? _sessionSubscription;

  SessionCubit({
    required this.getTotalSessionsUseCase,
    required this.startSessionUseCase,
    required this.addRoundUseCase,
    required this.watchSessionUseCase,
    required this.completeSessionUseCase,
    required this.getPlayersUseCase,
    required this.addPlayerUseCase,
  }) : super(SessionState());

  Future<void> loadSessionsCount() async {
    emit(state.copyWith(countStatus: UseCaseStatus.loading));
    final result = await getTotalSessionsUseCase();
    result.fold(
      (failure) => emit(state.copyWith(countStatus: UseCaseStatus.failure, countError: failure.message)),
      (count) => emit(state.copyWith(countStatus: UseCaseStatus.success, count: count)),
    );
  }

  Future<void> createSession({
    required String team1Name,
    required String team2Name,
    required int limit,
    List<String> team1PlayerIds = const [],
    List<String> team2PlayerIds = const [],
  }) async {
    emit(state.copyWith(sessionStatus: UseCaseStatus.loading));
    final session = Session(
      id: '', // Will be generated by Firestore
      date: DateTime.now(),
      team1Score: 0,
      team2Score: 0,
      limit: limit,
      team1Name: team1Name,
      team2Name: team2Name,
      team1PlayerIds: team1PlayerIds,
      team2PlayerIds: team2PlayerIds,
    );
    final result = await startSessionUseCase(session);
    result.fold((failure) => emit(state.copyWith(sessionStatus: UseCaseStatus.failure, sessionError: failure.message)), (sessionId) => watchSession(sessionId));
  }

  void watchSession(String sessionId) {
    _sessionSubscription?.cancel();
    _sessionSubscription = watchSessionUseCase(sessionId).listen((result) {
      print(result);
      result.fold(
        (failure) => emit(state.copyWith(sessionStatus: UseCaseStatus.failure, sessionError: failure.message)),
        (session) => emit(state.copyWith(sessionStatus: UseCaseStatus.success, session: session)),
      );
    });
  }

  Future<void> recordRound(String winningTeam, int points) async {
    final state = this.state;
    if (state.sessionStatus == UseCaseStatus.success && state.session != null) {
      final result = await addRoundUseCase(state.session!.id, winningTeam, points);
      result.fold((failure) => emit(state.copyWith(sessionStatus: UseCaseStatus.failure, sessionError: failure.message)), (_) {});
    }
  }

  Future<void> finishSession() async {
    final state = this.state;
    if (state.sessionStatus == UseCaseStatus.success && state.session != null) {
      final result = await completeSessionUseCase(state.session!.id);
      result.fold(
        (failure) => emit(state.copyWith(sessionStatus: UseCaseStatus.failure, sessionError: failure.message)),
        (_) => emit(state.copyWith(sessionStatus: UseCaseStatus.success, session: state.session)),
      );
    }
  }

  @override
  Future<void> close() {
    _sessionSubscription?.cancel();
    return super.close();
  }
}
